/* 
    INFO: Sort sweep colider that does quick collision detection on Axis-Aligned Boxes
    Used to track objects and will give information of collisions between items

    IMPORTANT: Do not edit this file
    This class works for what it does and will not be changed
    It was a hastle do make in the first place, just leave it
*/

import * as UTIL from './util.js'

interface ObjectInformation {
    indexes : number [][] ; 
    overlaps : Map < number, number > 
}

interface ObjectKeyPoint {
    value : number, 
    id : number, 
    open : boolean 
}

export class SortSweepCollider {

    dimensions : number ; 
    keyPointsByAxis : Map< number, ObjectKeyPoint [] > ; 
    objects : Map < number, ObjectInformation > 

    constructor ( dimensions : number ) {

        this.dimensions = dimensions;
        this.keyPointsByAxis = new Map< number, ObjectKeyPoint [] > ()
        this.objects = new Map < number, ObjectInformation > () 

        for ( ; dimensions > 0; dimensions -- )
            this.keyPointsByAxis.set ( dimensions - 1, [] )

    }

    /* private utils */


    private newBlankBlockObject () : ObjectInformation {
        return { 
            indexes : UTIL.newArray( this.dimensions, [0,0] ),
            overlaps : new Map < number, number > ()    
        }
    }

    private newObjectKeyPoint ( id : number, value : number, open : boolean ) {
        return {
            value : value,
            id : id, 
            open : open 
        }
    }

    private setKeyPointIndex ( axis : number, { id, open }, delta : number ) {
        this.objects.get( id ).indexes[ axis ][ open ? 0 : 1 ] += delta ;
    }

    private shiftKeyPoints ( index : number, axis : number, delta : number ) {

        let targetAxis = this.keyPointsByAxis.get ( axis )

        for ( ; index < targetAxis.length; index ++ ){
        
            let item = targetAxis[index];
            this.setKeyPointIndex( axis, { id : item.id , open : item.open }, delta )

        }
    }

    private getObjectAxisIndexes ( axis : number, id : number ) {
        return this.objects.get( id ).indexes[ axis ]
    }

    private addCollision ( id1, id2 ) {

        this.addOneWayCollision ( id1, id2 )
        this.addOneWayCollision ( id2, id1 )
    }

    private addOneWayCollision ( id1, id2 ) {

        if ( id1 == id2 ) return

        let obj = this.objects.get( id1 )

        if ( obj.overlaps.has( id2 ) )
            obj.overlaps.set( id2, obj.overlaps.get( id2 ) + 1)
        else
            obj.overlaps.set( id2, 1 )
    }

    private removeCollision ( id1, id2 ) {

        if ( id1 == id2 ) return

        this.removeOneWayCollision ( id1, id2 )
        this.removeOneWayCollision ( id2, id1 )
    }

    private removeOneWayCollision ( id1, id2 ) {
        
        let obj = this.objects.get ( id1 )
        let value = obj.overlaps.get ( id2 )

        if ( value == 1 )
            obj.overlaps.delete( id2 )
        else
            obj.overlaps.set( id2, value - 1 )

    }

    private isCriticalId ( id1, id2 ){
        return this.objects.get( id1 ).overlaps.get( id2 ) >= this.dimensions - 1;
    }

    /* Insert new blocks */

    insertBlock ( id : number, ... values : number []  ) : number {

        let newBlockObject =  this.newBlankBlockObject()
        
        this.objects.set( id, newBlockObject ) 

        for ( let axis = 0 ; axis < this.dimensions; axis ++ ) {
            this.insertValueOnAxis ( axis, this.newObjectKeyPoint( id, values[ axis ], true ) )
            this.insertValueOnAxis ( axis, this.newObjectKeyPoint( id, values[ axis + this.dimensions ], false ) )
            this.registerNewIdOnAxis ( axis, id )
        }

        return id 

    }

    private insertValueOnAxis ( axis : number, point : ObjectKeyPoint ) {

        let targetAxis = this.keyPointsByAxis.get( axis )
        let insertionIndex = UTIL.binarySearch( targetAxis, point.value, e => e.value )

        this.setKeyPointIndex( axis, point, insertionIndex )
        this.shiftKeyPoints ( insertionIndex, axis, 1 );

        targetAxis.splice( insertionIndex, 0, point )
    }

    private registerNewIdOnAxis ( axis : number, id : number ) {

        let targetAxis = this.keyPointsByAxis.get ( axis )
        let inSpan = false;

        let openSpans = new Set () 

        for ( let i = 0 ; i < targetAxis.length; i ++ ){

            let item = targetAxis[ i ]

            if ( item.open ) { 

                if ( item.id == id ) {
                    openSpans.forEach( e => this.addCollision ( e, id ) )
                    inSpan = true;
                }
                else if ( inSpan ) {
                    this.addCollision( id, item.id )
                }

                openSpans.add( item.id )

            }

            else {
                
                if ( item.id == id )
                    break;

                openSpans.delete( item.id )

            }

        }
    }

    /* Test collision */

    checkFreeMovement ( id : number, axis : number , delta : number ) {

        if ( delta == 0 ) return [ undefined, 0 ]

        let [ low, high ] = this.getObjectAxisIndexes ( axis, id )
        let targetAxis = this.keyPointsByAxis.get ( axis )

        if ( delta > 0 ) {
            let targetValue = targetAxis[ high ].value + delta;
            return this.checkFreeMovementSweepOnAxis ( axis, high, targetValue, delta, 1, id ) 
        }
        else {
            let targetValue = targetAxis[ low ].value + delta;
            return this.checkFreeMovementSweepOnAxis ( axis, low, targetValue, delta, -1, id ) 
        }


    }

    private checkFreeMovementSweepOnAxis ( axis : number, index : number, target : number, delta : number, increment : number, id : number ) : any {

        let targetAxis = this.keyPointsByAxis.get ( axis )

        let end = increment > 0 ? targetAxis.length : -1 ;
        let start = index + increment;

        return UTIL.forLoop ( start, increment, end, [ undefined, delta ] ,
            _index => {

                let item = targetAxis[ _index ]

                if ( increment > 0 ) {

                    if (item.value > target ) 
                        return [ undefined, delta ] 
                    if ( item.open && this.isCriticalId( item.id, id ) ){

                        let freeSpace = ( delta - ( target - item.value) ) + ( delta > 0 ? -0.01 : +0.01)
                        return [ item.id, freeSpace ]
                    }
                }

                else {
                    if (  item.value < target )
                        return [ undefined, delta ] 
                    if ( !item.open && this.isCriticalId( item.id, id ) ){

                        let freeSpace = ( delta - ( target - item.value) ) + ( delta > 0 ? -0.01 : +0.01)
                        return [ item.id, freeSpace ]
                    }
                }

            }    
        )

    }

    /* Do movement */

    doMovement ( id : number, axis : number, delta : number ) {
        
        if ( delta == 0 ) return []

        let [ low, high ] = this.getObjectAxisIndexes ( axis, id )
        let targetAxis = this.keyPointsByAxis.get ( axis )

        let targetLow = targetAxis[ low ].value + delta;
        let targetHigh = targetAxis[ high ].value + delta;

        if ( delta > 0 ) {
            this.movementOnAxis ( axis, high, targetHigh, 1, id ) 
            this.movementOnAxis ( axis, low, targetLow, 1, id )
        }
        else {
            this.movementOnAxis ( axis, low, targetLow, -1, id )
            this.movementOnAxis ( axis, high, targetHigh, -1, id ) 
        }

    }

    private movementOnAxis ( axis : number, index : number, target : number, increment : number, id : number) {

        let targetAxis = this.keyPointsByAxis.get ( axis )

        let movingItem = targetAxis [ index ]

        let end = increment > 0 ? targetAxis.length : -1 ;
        let start = index + increment;

        let final = UTIL.forLoop ( start, increment, end, undefined ,
            _index => {

                let item = targetAxis[ _index ]

                if ( increment > 0 ) {
                    
                    if ( item.value > target ) return _index - increment 

                    if ( movingItem.open && ! item.open ) {
                        this.removeCollision( movingItem.id, item.id)
                    }
                    else if ( ! movingItem.open && item.open ){                  
                        this.addCollision ( movingItem.id, item.id )

                    }
                }

                else {

                    if ( item.value < target ) return _index - increment 

                    if ( movingItem.open && ! item.open ) {
                        this.addCollision( movingItem.id, item.id)
                    }
                    else if ( ! movingItem.open && item.open ){
                        this.removeCollision ( movingItem.id, item.id )
                    }
                }

                UTIL.swapValues( targetAxis, _index, _index - increment ) 
                this.setKeyPointIndex( axis, item, - increment )

            }
        )

        final = final == undefined ? end - increment : final

        targetAxis[ final ].value = target;
        this.objects.get( id ).indexes[ axis ][ movingItem.open ? 0 : 1 ] = final


    }

    /* Combined */

    checkAndDoMovement ( id : number, axis : number, amount : number ) {

        let [hit, limit] = this.checkFreeMovement( id, axis, amount );
        this.doMovement( id, axis, limit )

        return [hit, limit]; 

    }

    /* Debuging */

    debugLog ( ) {
        console.log( 'axises y', this.keyPointsByAxis.get( 1 ).map( i => JSON.stringify(i)).join(',\n') )
    }

    debugDimentions ( item : number ) {

        let indexes = this.objects.get( item ).indexes
        
        let getRange = ( axis : number ) => {
            let [low, high] = indexes[axis]
            let axis_ref = this.keyPointsByAxis.get(axis)
            return Math.round((axis_ref[high].value - axis_ref[low].value) * 100000) /100000
        }

        console.log(`KEY: ${item}  x: ${getRange(0)}, y: ${getRange(1)}, z: ${getRange(2)}`)

    }

}
